<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HttpServerRoute.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">instrumentation-api</a> &gt; <a href="index.source.html" class="el_package">io.opentelemetry.instrumentation.api.semconv.http</a> &gt; <span class="el_source">HttpServerRoute.java</span></div><h1>HttpServerRoute.java</h1><pre class="source lang-java linenums">/*
 * Copyright The OpenTelemetry Authors
 * SPDX-License-Identifier: Apache-2.0
 */

package io.opentelemetry.instrumentation.api.semconv.http;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.context.Context;
import io.opentelemetry.instrumentation.api.instrumenter.ContextCustomizer;
import io.opentelemetry.instrumentation.api.instrumenter.Instrumenter;
import io.opentelemetry.instrumentation.api.instrumenter.InstrumenterBuilder;
import io.opentelemetry.instrumentation.api.internal.HttpRouteState;
import javax.annotation.Nullable;

/**
 * A helper class that keeps track of the {@code http.route} attribute value during HTTP server
 * request processing.
 *
 * &lt;p&gt;Usually the route is not accessible when the request processing starts; and needs to be set
 * later, after the instrumented operation starts. This class provides several static methods that
 * allow the instrumentation author to provide the matching HTTP route to the instrumentation when
 * it is discovered.
 *
 * @since 2.0.0
 */
public final class HttpServerRoute {

  /**
   * Returns a {@link ContextCustomizer} that initializes an {@link HttpServerRoute} in the {@link
   * Context} returned from {@link Instrumenter#start(Context, Object)}.
   *
   * @see InstrumenterBuilder#addContextCustomizer(ContextCustomizer)
   */
  public static &lt;REQUEST&gt; ContextCustomizer&lt;REQUEST&gt; create(
      HttpServerAttributesGetter&lt;REQUEST, ?&gt; getter) {
<span class="fc" id="L37">    return builder(getter).build();</span>
  }

  /**
   * Returns a new {@link HttpServerRouteBuilder} that can be used to configure the {@link
   * HttpServerRoute}.
   */
  public static &lt;REQUEST&gt; HttpServerRouteBuilder&lt;REQUEST&gt; builder(
      HttpServerAttributesGetter&lt;REQUEST, ?&gt; getter) {
<span class="fc" id="L46">    return new HttpServerRouteBuilder&lt;&gt;(getter);</span>
  }

  private HttpServerRoute() {}

  /**
   * Updates the {@code http.route} attribute in the received {@code context}.
   *
   * &lt;p&gt;If there is a server span in the context, and the context has been customized with a {@link
   * HttpServerRoute}, then this method will update the route using the provided {@code httpRoute}
   * if and only if the last {@link HttpServerRouteSource} to update the route using this method has
   * strictly lower priority than the provided {@link HttpServerRouteSource}, and the passed value
   * is non-null.
   */
  public static void update(
      Context context, HttpServerRouteSource source, @Nullable String httpRoute) {
<span class="fc" id="L62">    update(context, source, ConstantAdapter.INSTANCE, httpRoute);</span>
<span class="fc" id="L63">  }</span>

  /**
   * Updates the {@code http.route} attribute in the received {@code context}.
   *
   * &lt;p&gt;If there is a server span in the context, and the context has been customized with a {@link
   * HttpServerRoute}, then this method will update the route using the provided {@link
   * HttpServerRouteGetter} if and only if the last {@link HttpServerRouteSource} to update the
   * route using this method has strictly lower priority than the provided {@link
   * HttpServerRouteSource}, and the value returned from the {@link HttpServerRouteGetter} is
   * non-null.
   */
  public static &lt;T&gt; void update(
      Context context,
      HttpServerRouteSource source,
      HttpServerRouteGetter&lt;T&gt; httpRouteGetter,
      T arg1) {
<span class="fc" id="L80">    update(context, source, OneArgAdapter.getInstance(), arg1, httpRouteGetter);</span>
<span class="fc" id="L81">  }</span>

  /**
   * Updates the {@code http.route} attribute in the received {@code context}.
   *
   * &lt;p&gt;If there is a server span in the context, and the context has been customized with a {@link
   * HttpServerRoute}, then this method will update the route using the provided {@link
   * HttpServerRouteBiGetter} if and only if the last {@link HttpServerRouteSource} to update the
   * route using this method has strictly lower priority than the provided {@link
   * HttpServerRouteSource}, and the value returned from the {@link HttpServerRouteBiGetter} is
   * non-null.
   */
  public static &lt;T, U&gt; void update(
      Context context,
      HttpServerRouteSource source,
      HttpServerRouteBiGetter&lt;T, U&gt; httpRouteGetter,
      T arg1,
      U arg2) {
<span class="fc" id="L99">    HttpRouteState httpRouteState = HttpRouteState.fromContextOrNull(context);</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">    if (httpRouteState == null) {</span>
<span class="nc" id="L101">      return;</span>
    }
<span class="fc" id="L103">    Span serverSpan = httpRouteState.getSpan();</span>
    // even if the server span is not sampled, we have to continue - we need to compute the
    // http.route properly so that it can be captured by the server metrics
<span class="fc bfc" id="L106" title="All 2 branches covered.">    if (serverSpan == null) {</span>
<span class="fc" id="L107">      return;</span>
    }

    // special case for servlet filters, even when we have a route from previous filter see whether
    // the new route is better and if so use it instead
<span class="fc bfc" id="L112" title="All 2 branches covered.">    boolean onlyIfBetterRoute =</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        !source.useFirst &amp;&amp; source.order == httpRouteState.getUpdatedBySourceOrder();</span>
<span class="fc bfc" id="L114" title="All 4 branches covered.">    if (source.order &gt; httpRouteState.getUpdatedBySourceOrder() || onlyIfBetterRoute) {</span>
<span class="fc" id="L115">      String route = httpRouteGetter.get(context, arg1, arg2);</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">      if (route != null</span>
<span class="pc bpc" id="L117" title="1 of 4 branches missed.">          &amp;&amp; !route.isEmpty()</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">          &amp;&amp; (!onlyIfBetterRoute || isBetterRoute(httpRouteState, route))) {</span>

        // update just the span name - the attribute will be picked up by the
        // HttpServerAttributesExtractor at the end of request processing
<span class="fc" id="L122">        updateSpanName(serverSpan, httpRouteState, route);</span>

<span class="fc" id="L124">        httpRouteState.update(context, source.order, route);</span>
      }
    }
<span class="fc" id="L127">  }</span>

  // This is used when setting route from a servlet filter to pick the most descriptive (longest)
  // route.
  private static boolean isBetterRoute(HttpRouteState httpRouteState, String name) {
<span class="fc" id="L132">    String route = httpRouteState.getRoute();</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">    int routeLength = route == null ? 0 : route.length();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">    return name.length() &gt; routeLength;</span>
  }

  private static void updateSpanName(Span serverSpan, HttpRouteState httpRouteState, String route) {
<span class="fc" id="L138">    String method = httpRouteState.getMethod();</span>
    // method should never really be null
<span class="fc" id="L140">    serverSpan.updateName(method + &quot; &quot; + route);</span>
<span class="fc" id="L141">  }</span>

  /**
   * Returns the {@code http.route} attribute value that's stored in the {@code context}, or null if
   * it was not set before.
   */
  @Nullable
  static String get(Context context) {
<span class="fc" id="L149">    HttpRouteState httpRouteState = HttpRouteState.fromContextOrNull(context);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">    return httpRouteState == null ? null : httpRouteState.getRoute();</span>
  }

  private static final class OneArgAdapter&lt;T&gt;
      implements HttpServerRouteBiGetter&lt;T, HttpServerRouteGetter&lt;T&gt;&gt; {

<span class="fc" id="L156">    private static final OneArgAdapter&lt;Object&gt; INSTANCE = new OneArgAdapter&lt;&gt;();</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; OneArgAdapter&lt;T&gt; getInstance() {
<span class="fc" id="L160">      return (OneArgAdapter&lt;T&gt;) INSTANCE;</span>
    }

    @Override
    @Nullable
    public String get(Context context, T arg, HttpServerRouteGetter&lt;T&gt; httpRouteGetter) {
<span class="fc" id="L166">      return httpRouteGetter.get(context, arg);</span>
    }
  }

  private static final class ConstantAdapter implements HttpServerRouteGetter&lt;String&gt; {

<span class="fc" id="L172">    private static final ConstantAdapter INSTANCE = new ConstantAdapter();</span>

    @Nullable
    @Override
    public String get(Context context, String route) {
<span class="fc" id="L177">      return route;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>